# 输出段 虚拟地址

每个段都有一个虚拟地址（virtual address）和加载地址（load address）。
加载地址用 **AT** 或 **AT>** 关键字指定。声明一个加载地址是可选的。

**AT** 关键字接受一个表达式当作参数。这个参数指定了段的确切的加载地址。
**AT>** 关键字接受一个内存区域名字当作参数。详情 MEMORY。
段的加载地址被设为区域中下一个空闲地址，对齐按照段的对其要求。

如果可分配段的 **AT** 和 **AT>** 都没有指定，链接器将会使用如下的方法来确定加载地址：

- 如果段有一个指定的虚拟地址，那么加载地址也是它。

- 如果段是不可分配的，那么加载地址设为虚拟地址。

- 否则如果内存区域被发现是和当前段兼容，并且区域至少包含了一个段，
那么就设置加载地址，使得虚拟地址和加载地址的差别和被分配区域的最后一个段的虚拟地址和加载地址的差别相同。

- 如果没有内存区域被声明，使用覆盖整个地址空间的默认区域用于上一个步骤。

- 如果没有发现合适的区域，或者没有先前的段，那么虚拟地址和加载地址相同。

这个功能被设计用于很简单的创立一个ROM映像。比如，如下的链接脚本创建了三个段：
一个是 `.text`，开始于 `0x1000`
一个是 `.mdata`，加载到 `.text` 段之后，即使他的虚拟地址是 `0x200`
一个是 `.bss`，保存未初始化的数据，在地址 `0x3000`。
符号 `_data` 被定义为 `0x2000`，表明了位置计数器储存了虚拟地址的值，为不是加载地址的值。

```ld
    SECTIONS
        {
        .text 0x1000 : { *(.text) _etext = . ; }
        .mdata 0x2000 :
            AT ( ADDR (.text) + SIZEOF (.text) )
            { _data = . ; *(.data); _edata = . ;  }
        .bss 0x3000 :
            { _bstart = . ;  *(.bss) *(COMMON) ; _bend = . ;}
    }
```

此链接器脚本生成的程序使用的运行时初始化代码包括如下内容，用于将初始化的数据从ROM映像复制到其运行时地址。
请观察这些代码是如何利用链接器脚本定义符号的。

```c
     extern char _etext, _data, _edata, _bstart, _bend;
     char *src = &_etext;
     char *dst = &_data;
     
     /* ROM has data at end of text; copy it.  */
     while (dst < &_edata)
       *dst++ = *src++;
     
     /* Zero bss.  */
     for (dst = &_bstart; dst< &_bend; dst++)
       *dst = 0;
```
